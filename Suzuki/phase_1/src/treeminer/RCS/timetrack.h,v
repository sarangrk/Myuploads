head	1.2;
access;
symbols;
locks
	zaki:1.2; strict;
comment	@ * @;


1.2
date	2001.06.24.19.16.01;	author zaki;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.06.00.04.45;	author zaki;	state Exp;
branches;
next	;


desc
@@


1.2
log
@added pruning.
@
text
@#include <sys/time.h>
#include <unistd.h>  

#define microsec 1000000.0

class TimeTracker {
private:
   struct timeval start_time;
   struct timeval stop_time;
   bool  running;
public:
   TimeTracker() {
      running=false;
   }
   
   void Start() {
      gettimeofday(&start_time, (struct timezone *)0);
      running=true;
   }
   
  double Stop() {
     double st, en;
     if (!running) return(-1.0);
     else {
        gettimeofday(&stop_time, (struct timezone *)0);
        st = start_time.tv_sec + (start_time.tv_usec/microsec);
        en = stop_time.tv_sec + (stop_time.tv_usec/microsec);
        running=false;
        return (double)(en - st);
     }
  }
};


@


1.1
log
@Initial revision
@
text
@d1 2
a2 2
#ifndef _timetrack_h
#define _timetrack_h
d4 1
a4 2
#include <time.h>
#include <sys/times.h>
d7 11
a17 16
 private:
  clock_t   start_user;
  clock_t   start_sys;
  bool  running;
 public:
  TimeTracker() {
    start_user=start_sys=0;
    running=false;
  }

  void Start() {
    struct  tms     l_time;

    if (times(&l_time) != -1) {
      start_user = l_time.tms_utime;
      start_sys  = l_time.tms_stime;
d19 2
a20 3
    }
  }

d22 9
a30 13
    struct  tms     l_time;
    clock_t   stop_user;
    clock_t   stop_sys;

    if ((!running) || (times(&l_time) == -1)) {
      return(-1.0);
    } else {
      stop_user = l_time.tms_utime;
      stop_sys  = l_time.tms_stime;
      running=false;
      return( ((double)(stop_user - start_user))/(double) CLK_TCK + 
              ((double)(stop_sys-start_sys))/(double)CLK_TCK);
    }
d34 1
a34 1
#endif
@
