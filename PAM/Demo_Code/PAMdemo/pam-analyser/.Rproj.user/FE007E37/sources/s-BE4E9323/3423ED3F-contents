# UI for failure models
#' @export
resultsTabUI <- function(id) {
  
  ns <- NS(id)
  
  # Tab consists of Panel with controls and output
  tabPanel(
    results_tab(),
    # tags$head(
    #   includeCSS("stylesleaflet.css"),
    #   includeScript("gomap.js")
    # ),
    h2('Maintenance plan'),
    p("Use the controls below to find which of your assets will need maintenance; these values are automatically updated after you have run the optimisation. Green assets on the map do not need maintenance, but those in red have a failure probability larger than your alarm threshold. To make the map larger you can close the menu using the icon on the top right of the page."),
    fluidRow(
      box(width = 12,
          div(class = 'outer',
              leafletOutput(ns("maintenance_map"), height = '750px'),
              absolutePanel(id = "controls", class = "controls panel panel-default", fixed = FALSE, draggable = TRUE,
                            top = 30, left = 70, right = "auto", bottom = "auto", width = "auto", height = "auto",
                            h3('Model settings', style = 'margin-top:10px'),
                            selectInput(ns("modelSelectTwo"), label="Machine learning model", choices = initial_models),
                            sliderInput(ns("ForecastHorizon"), label="Failure time frame (days)", value = 45, max = 365, min = 0),
                            sliderInput(ns("AlarmThresholdTwo"), label = "Alarm threshold (failure probability)", value = 0.25, max = 1, min = 0),
                            actionButton(ns('create_plan'), 'Create maintenance plan')
              ),
              conditionalPanel(sprintf("input['%s'] > 0", ns("create_plan")),
                               absolutePanel(id = "repair_list", class = "controls panel panel-default scroll",
                                             fixed = FALSE, draggable = TRUE,
                                             top = 30, left = "auto", right = 20, bottom = "auto", width = '400', height = "500",
                                             h3('Prioritisation', style = 'margin-top:10px'),
                                             p('Assets with a failure probability greater than the alarm threshold are listed below, ordered by those assets which are most likely to fail.'),
                                             DT::dataTableOutput(ns("asset_maintenance_plan")),
                                             downloadButton(ns('download_maintenance_plan'), 'Download plan')
                               )
              )
          )
      )
    )
  )
}


# Server
#' @export
resultsTab <- function(input, output, session, navpage) {
  
  #### Model Selection And Output ####
  observe({
    updateNumericInput(session, 'AlarmThresholdTwo', value = input$AlarmThreshold)
  })
  
  observe({
    updateNumericInput(session, 'ForecastHorizon', value = input$TimeHorizonInput)
  })
  
  observe({
    updateSelectInput(session, 'modelSelectTwo', choices = models_to_build$list)
  })
  
  observe({
    updateSelectInput(session, 'modelSelectTwo', selected = input$modelSelect)
  })
  
  observe({
    if (is.null(input$goto))
      return()
    isolate({
      map <- leafletProxy("map")
      map %>% clearPopups()
      dist <- 0.5
      zip <- input$goto$zip
      lat <- input$goto$lat
      lng <- input$goto$lng
      showPopup(zip, lat, lng)
      map %>% fitBounds(lng - dist, lat - dist, lng + dist, lat + dist)
    })
  })
  
  ### Leaflet map #####
  prepMapData <- reactive({
    plot_mapdata <- processedRoCData()
    plot_mapdata$ColorVar <- ifelse(plot_mapdata$failure_probability >= model_variables()$AlarmThreshold, 
                                    'Maintenance required', 'Working correctly')
    
    return(plot_mapdata)
  })
  
  ## Update leaflet map ##
  observe({
    # Fire if the controls modified
    model_variables()
    
    # Only change if validation_forecast is done
    if(validationForecastReady()) {
      # Get Map data
      plot_mapdata <- prepMapData()
      plot_update(plot_mapdata)
    }
  })
  
  ## Reset rendering if click on tab
  observeEvent(navpage(), {
    # Only change if validation_forecast is done and clicked on right page
    if(validationForecastReady() && navpage() == results_tab()) {
      # Fire if the controls modified
      model_variables()
      
      ## Re-render map
      # Get Map data
      plot_mapdata <- prepMapData()
      plot_update(plot_mapdata)
    }
  })
  
  plot_update <- function(plot_mapdata){
    # Replot
    pal <- colorFactor(c('red', 'green'), c('Maintenance required','Working correctly'))
    leafletProxy("maintenance_map", data = plot_mapdata) %>%
      clearShapes() %>%  # when addCircles is used
      clearMarkers() %>% # when addCircleMarkers is used
      clearPopups() %>% # clear popups
      addCircleMarkers(~longitude, ~latitude, radius = 5, layerId=~asset_id,
                       stroke=TRUE, fillOpacity=0.9, fillColor=pal(plot_mapdata$ColorVar), color = "black", weight = 1) %>%
      addLegend("bottomright", pal=pal, values=plot_mapdata$ColorVar,
                layerId="colorLegend")
  }
  
  ## Add Popups ##
  # Does not update on change of sliders - it is cleared
  observe({
    # Only change if validation_forecast
    event <- input$maintenance_map_marker_click
    if(validationForecastReady()){
      leafletProxy("maintenance_map") %>% clearPopups()
      if (is.null(event))
        return()
      isolate({
        showPopup(event$id, event$lat, event$lng)
      })
    }
  })
  
  ## Show a popup at the given location ##
  #' @export
  showPopup <- function(asset_id, lat, lng) {
    options('scipen'=100,'digits'=5)
    
    roc_data <- processedRoCData()
    roc_data <- roc_data %>% group_by(asset_id) %>% mutate(rn = row_number(as.Date(event_date))) %>% filter(rn == max(rn)) %>% select(-rn)
    
    selectedAsset <- roc_data[roc_data$asset_id == asset_id,]
    selectedAsset <- selectedAsset[1, ]
    selected_model <- model_variables()$modelSelect
    content <- popupContent(selectedAsset, selected_model, model_variables()$TimeHorizonInput)
    
    leafletProxy("maintenance_map") %>% addPopups(lng, lat, content, layerId = asset_id)
  }
  counts <- table(mtcars$gear)

  popupContent <- function(selectedAsset, selected_model, time_horizon) {
    stats_table <- global_dataset$processed$full %>% filter(asset_id == selectedAsset$asset_id) %>% group_by(asset_id) %>% mutate(rn = row_number(as.Date(event_date))) %>% filter(rn == max(rn)) %>% select(-rn)
    attributes <- attributes_for_modelling(stats_table)
    rownames(stats_table) <- stats_table$asset_id
    stats_table <- t(stats_table[attributes])
    # 
    # return(paste0(
    #   as.character(tags$div(
    #     tags$h4(as.character(selectedAsset$asset_id)),
    #     p(paste0("Predicted failure probability in the next ", time_horizon, " days using ", selected_model, ": ", format(100*selectedAsset$failure_probability, small.mark = '.', nsmall = 3),'%'))
    #   )),
    #   print(xtable(stats_table), type = 'html', print.results = FALSE),
    #   barplot(counts, main="Car Distribution", xlab="Number of Gears")
    # ))
    
    fldr <- tempfile()
    dir.create(fldr)
    
    p <- barplot(counts, main="Car Distribution", xlab="Number of Gears")
    
    svg(filename = paste(fldr, "test.svg", sep = "/"), 
        width = 250 * 0.01334, height = 250 * 0.01334)
    print(p)
    dev.off()
    
    tst <- paste(readLines(paste(fldr, "test.svg", sep = "/")), collapse = "")
    
    return(tst)
  }
  
  
  model_variables <- eventReactive(input$create_plan, {
    list(
      modelSelect = input$modelSelectTwo,
      TimeHorizonInput = input$ForecastHorizon,
      AlarmThreshold = input$AlarmThresholdTwo
    )
  })
  
  # Process RoC Data
  processedRoCData <- reactive({
    rocr_data <- extractROCData()
    rocr_data$failure_probability <- 1 - rocr_data$predict # 1 - probability_of_survival = probability_failure
    rocr_data$failures <- ifelse(rocr_data$failure_probability >= as.numeric(model_variables()$AlarmThreshold) / 100, 1,0)
    rocr_data$failures <- factor(rocr_data$failures, levels = c("0","1"))
    rocr_data$labels <- factor(rocr_data$labels, levels = c("0","1"))
    return(rocr_data)
  })
  
  extractROCData <- reactive({
    time <- as.numeric(model_variables()$TimeHorizonInput)
    rocr_data <- calculate_validation_forecast() # Recalculate ROC data when time or model changed
    rocr_data$labels <- ifelse(rocr_data[,"event_occurred"] == 0, 0, ifelse(rocr_data[,"survival_time"]>=time, 0, 1))
    
    # rocr_data <- rocr_data[!((rocr_data$event_occurred == 0) && (rocr_data$survival_time < time)),]
    rocr_data$failure_probability <- 1 - rocr_data$predict # 1 - probability_of_survival = probability_failure
    return(rocr_data)
  })
  
  #### Update Validation Forecast on change of
  calculate_validation_forecast <- reactive({
    selected_model <- model_variables()$modelSelect
    forecast_time <- as.numeric(model_variables()$TimeHorizonInput)
    valid_suffix <- validationSuffix(selected_model)
    
    recent_data <- global_dataset$processed$full %>%
      group_by(asset_id) %>%
      arrange(installed_date) %>%
      filter(row_number()==n())
    
    model_data <- recent_data %>%
      select(one_of(attributes_for_modelling(recent_data)))
    
    recent_data <- as.data.frame(recent_data)
    model_data <- as.data.frame(model_data)
    
    # Make predictions on validation set
    withProgress(message="Forecasting...", value=0, {
      # Get model to forecast
      model_to_forecast <- fitted_model(selected_model)
      
      # Validate CoxPH linear fit
      probs <- predictSurvProb(model_to_forecast, newdata = model_data, times = forecast_time)
      incProgress(1, detail="Forecasting... Complete")
    })
    
    # Make sure that NAs are set to 0
    probs <- ifelse(is.na(probs), 0, probs)
    
    # Update names and bind to forecast
    colnames(probs) <- "predict"
    
    # Bind together along with survival time and event occurrence
    new_forecast <- cbind(recent_data, probs)
    
    return(new_forecast)
  })
  
  maintenance_plan <- reactive({
    model_variables()
    page_bool <- navpage() == results_tab()
    if(!(validationForecastReady() && page_bool)) return()
    
    roc_data <- processedRoCData()
    roc_data <- roc_data %>% group_by(asset_id) %>% 
      mutate(rn = row_number(as.Date(event_date))) %>% 
      filter(rn == max(rn)) %>% 
      filter(failure_probability >= model_variables()$AlarmThreshold) %>% 
      select(-rn) %>%
      arrange(desc(failure_probability))
    
    roc_data <- roc_data[c('asset_id', 'failure_probability', 'latitude', 'longitude')]
    
    # DT::datatable(roc_data,
    #               options = list(searching = FALSE, pageLength = 15))
    roc_data
  })
  
  output$asset_maintenance_plan <- DT::renderDataTable({
    df <- maintenance_plan()
    if (is.null(df)) return()
    
    df <- df %>%
      mutate(Find = paste('<a class="go-map" href="" data-lat="', latitude, '" data-long="', longitude, '" data-zip="', asset_id, '"><span class="fa fa-crosshairs"></span></a>', sep="")) %>%
      mutate(failure_probability = sprintf('%.2f%%', 100*failure_probability)) %>%
      select(one_of(c("asset_id", "failure_probability", 'Find'))) %>%
      rename(`Failure probability` = 'failure_probability', `Asset ID` = asset_id)
    
    action <- DT::dataTableAjax(session, df)
    
    DT::datatable(df, options = list(ajax = list(url = action), searching = FALSE, pageLength = 15), escape = FALSE)
  })
  
  output$download_maintenance_plan <- downloadHandler(
    filename = function() { paste0('maintenance_plan_',gsub('[ :]+', '_', Sys.time()),'.csv') },
    content = function(file) {
      write.csv(maintenance_plan(), file)
    }
  )
  
  output$maintenance_map <- renderLeaflet({
    if ((input$create_plan == 0) || (!validationForecastReady())) {
      leaflet() %>%
        addTiles() %>%
        setView(lng = 1, lat = 55, zoom = 5) %>%
        addLayersControl(position = "bottomleft",
                         baseGroups = c("OSM","Topographical","Satellite"),
                         options = layersControlOptions(collapse = TRUE)) %>%
        addProviderTiles("OpenStreetMap.BlackAndWhite", group = "OSM") %>%
        addProviderTiles("Thunderforest.Landscape",     group = "Topographical") %>%
        addProviderTiles("Esri.WorldImagery",           group = "Satellite")
      
    } else {
      map_data <- prepMapData()
      
      leaflet() %>%
        addTiles() %>%
        setView(lng = mean(map_data$longitude), lat = mean(map_data$latitude), zoom = 5) %>%
        addLayersControl(position = "bottomleft",
                         baseGroups = c("OSM","Topographical","Satellite"),
                         options = layersControlOptions(collapse = TRUE)) %>%
        addProviderTiles("OpenStreetMap.BlackAndWhite", group = "OSM") %>%
        addProviderTiles("Thunderforest.Landscape",     group = "Topographical") %>%
        addProviderTiles("Esri.WorldImagery",           group = "Satellite") %>%
        addCircleMarkers(lng = map_data$longitude, map_data$latitude, radius = 7, layerId = map_data$asset_id,
                         stroke=TRUE, fillOpacity=0.9, fillColor="#F8766D", color = "black", weight = 1)
    }
  })
}

