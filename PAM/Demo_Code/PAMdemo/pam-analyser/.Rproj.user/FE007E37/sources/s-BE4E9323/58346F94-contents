# Any code in this file is guaranteed to be called before either
# ui.R or server.R

rm(list=c(ls()))

### Load Packages ##############################################################
print(.libPaths())
if(!require(shiny))       {install.packages('shiny', dependencies = TRUE);require(shiny)}
if(!require(ggplot2))     {install.packages('ggplot2', dependencies = TRUE);require(ggplot2)}
if(!require(plotly))      {install.packages('plotly', dependencies = TRUE);require(plotly)}
if(!require(rpivotTable)) {devtools::install_github(c("ramnathv/htmlwidgets", "smartinsightsfromdata/rpivotTable"))}

if(!require(gplots))      {install.packages('gplots', dependencies = TRUE);require(gplots)}
if(!require(plyr))        {install.packages('plyr', dependencies = TRUE);require(plyr)}
if(!require(dplyr))       {install.packages('dplyr', dependencies = TRUE);require(dplyr)}
if(!require(lubridate))   {install.packages('lubridate', dependencies = TRUE);require(lubridate)}
if(!require(gridExtra))   {install.packages('gridExtra', dependencies = TRUE);require(gridExtra)}
if(!require(stringr))     {install.packages('stringr', dependencies = TRUE);require(stringr)}
if(!require(survival))    {install.packages('survival', dependencies = TRUE);require(survival)}
if(!require(grid))        {install.packages('grid', dependencies = TRUE);require(grid)}
if(!require(ROCR))        {install.packages('ROCR', dependencies = TRUE);require(ROCR)}
if(!require(caret))       {install.packages('caret', dependencies = TRUE);require(caret)}
if(!require(e1071))       {install.packages('e1071', dependencies = TRUE);require(e1071)}
if(!require(devtools))       {install.packages('devtools', dependencies = TRUE);require(devtools)}
# leaflet maps

if(!require(leaflet))      {install.packages('leaflet');require(leaflet)}
if(!require(RColorBrewer)) {install.packages('RColorBrewer');require(RColorBrewer)}
if(!require(scales))       {install.packages('scales');require(scales)}
if(!require(lattice))      {install.packages('lattice');require(lattice)}

# own package - install from git and deploy in the local lib in the server
#library(switches)

if(!require(switches)) {devtools::install_github('ThinkBigAnalytics/DataScience/Offers/PAM/Manufacturing-Trains-Switches', auth_token='2906e2eadca17b0d31e5217723d860a7974dc68b');require(switches)}

### Load R Scripts #############################################################

# # intro
# source("introTab.R")
# source("workflowTab.R")
# # failures profiling
# source("selectSwitch.R")
# source("numFailuresTab.R")
# source("failuresProfilingTab.R")
# source("failuresProfilingBasicTab.R")
# # failures analysis
# source("kaplanTab.R")
# # failures modelling
# source("failuresModelTab.R")
# # maps
# source("leafletTab.R")
# source("leafletForecastTab.R")
# # utils
# source("multiplot.R")

### Load Data ##################################################################

load("data/SwitchesMasterAnonymized.RData")
load("data/faultsMasterAnonymized.RData")
load("data/SurvivalAnonymized.RData")

# subsample data for performance issues
set.seed(42)
subsample <- sample(SwitchesMaster$ipid, 10000)
SwitchesMaster <- SwitchesMaster[SwitchesMaster$ipid %in% subsample,]
SwitchesMaster <- droplevels(SwitchesMaster)
survival <- survival[survival$ipid %in% subsample,]
survival <- droplevels(survival)
#faultsMaster <- faultsMaster[faultsMaster$switch_abk %in% subsample,]

SwitchesMaster$V1  <- as.factor(SwitchesMaster$V1)
SwitchesMaster$V2  <- as.factor(SwitchesMaster$V2)
SwitchesMaster$V3  <- as.factor(SwitchesMaster$V3)
SwitchesMaster$V4  <- as.factor(SwitchesMaster$V4)


survival$V1  <- as.factor(survival$V1)
survival$V2  <- as.factor(survival$V2)
survival$V3  <- as.factor(survival$V3)
survival$V4  <- as.factor(survival$V4)

survival$V10  <- as.factor(survival$V10)
survival$V13  <- as.factor(survival$V13)

# replace "," with ";" in the factor levels

InputChoices <- c('V7',
                  'V8')

for(i in InputChoices){
  levels(survival[,i]) <- gsub(",",";",levels(survival[,i]))
}

validation01 <- read.table("data/Validation_Forecast_1.txt", sep = ",", header = TRUE)
validationForecast <- read.table("data/Validation_Forecast_Map_1.txt", sep = ",", header = TRUE)

# Add coordinates to Forecast
validationForecast <- merge(validationForecast, SwitchesMaster[,c("ipid","lng","lat")])

### Functions ##################################################################

gg_color_hue <- function(n) {
  hues = seq(15, 375, length=n+1)
  hcl(h=hues, l=65, c=100)[1:n]
}

createSurvivalFrame <- function(f.survfit){
  # initialise frame variable
  f.frame <- NULL
  # check if more then one strata
  if(length(names(f.survfit$strata)) == 0){
    # create data.frame with data from survfit
    f.frame <- data.frame(time=f.survfit$time, n.risk=f.survfit$n.risk, n.event=f.survfit$n.event, n.censor = f.survfit
                          $n.censor, surv=f.survfit$surv, upper=f.survfit$upper, lower=f.survfit$lower)
    # create first two rows (start at 1)
    f.start <- data.frame(time=c(0, f.frame$time[1]), n.risk=c(f.survfit$n, f.survfit$n), n.event=c(0,0),
                          n.censor=c(0,0), surv=c(1,1), upper=c(1,1), lower=c(1,1))
    # add first row to dataset
    f.frame <- rbind(f.start, f.frame)
    # remove temporary data
    rm(f.start)
  }
  else {
    # create vector for strata identification
    f.strata <- NULL
    for(f.i in 1:length(f.survfit$strata)){
      # add vector for one strata according to number of rows of strata
      f.strata <- c(f.strata, rep(names(f.survfit$strata)[f.i], f.survfit$strata[f.i]))
    }
    # create data.frame with data from survfit (create column for strata)
    f.frame <- data.frame(time=f.survfit$time, n.risk=f.survfit$n.risk, n.event=f.survfit$n.event, n.censor = f.survfit
                          $n.censor, surv=f.survfit$surv, upper=f.survfit$upper, lower=f.survfit$lower, strata=factor(f.strata))
    # remove temporary data
    rm(f.strata)
    # create first two rows (start at 1) for each strata
    for(f.i in 1:length(f.survfit$strata)){
      # take only subset for this strata from data
      f.subset <- subset(f.frame, strata==names(f.survfit$strata)[f.i])
      # create first two rows (time: 0, time of first event)
      f.start <- data.frame(time=c(0, f.subset$time[1]), n.risk=rep(f.survfit[f.i]$n, 2), n.event=c(0,0),
                            n.censor=c(0,0), surv=c(1,1), upper=c(1,1), lower=c(1,1), strata=rep(names(f.survfit$strata)[f.i],
                                                                                                 2))
      # add first two rows to dataset
      f.frame <- rbind(f.start, f.frame)
      # remove temporary data
      rm(f.start, f.subset)
    }
    # reorder data
    f.frame <- f.frame[order(f.frame$strata, f.frame$time), ]
    # rename row.names
    rownames(f.frame) <- NULL
  }
  # return frame
  return(f.frame)
}

### Print confusionMatrix ------------------------------------------------------

print.confusionMatrix <- function(x, digits = max(3, getOption("digits") - 3), printStats = TRUE, ...)
{
  cat("Confusion Matrix and Statistics\n")
 #  print(x$table, ...)

  #   cat("\n(columns are reference results, rows are predictions)\n")

  if(printStats)
  {

    tmp <- round(x$overall, digits = digits)
    pIndex <- grep("PValue", names(x$overall))
    tmp[pIndex] <- format.pval(x$overall[pIndex], digits = digits)
    overall <- tmp

    accCI <- paste(
      "(",
      paste(
        overall[ c("AccuracyLower", "AccuracyUpper")],
        collapse = ", "),
      ")",
      sep = "")

    overallText <- c(
      paste(overall["Accuracy"]),
      accCI,
      paste(overall[c("AccuracyNull", "AccuracyPValue")]),
      "",
      paste(overall["Kappa"]),
      paste(overall["McnemarPValue"]))

    overallNames <- c("Accuracy", "95% CI",
                      "No Information Rate",
                      "P-Value [Acc > NIR]",
                      "",
                      "Kappa",
                      "Mcnemar's Test P-Value")

    if(dim(x$table)[1] > 2)
    {
      cat("\nOverall Statistics\n")
      overallNames <- ifelse(
        overallNames == "",
        "",
        paste(overallNames, ":"))
      out <- cbind(
        format(overallNames, justify = "right"),
        overallText)
      colnames(out) <- rep("", ncol(out))
      rownames(out) <- rep("", nrow(out))

      print(out, quote = FALSE)

      cat("\nStatistics by Class:\n\n")
      print(t(x$byClass), digits = digits)

    } else {

      overallText <- c(
        overallText,
        "",
        format(x$byClass, digits = digits))
      overallNames <- c(
        overallNames,
        "",
        names(x$byClass))
      overallNames <- ifelse(
        overallNames == "",
        "",
        paste(overallNames, ":"))

#       overallNames <- c(overallNames,
#                         "",
#                         "'Positive' Class :")
#       overallText <- c(overallText,
#                        "",
#                        x$positive)

      out <- cbind(
        format(overallNames, justify = "right"),
        overallText)
      colnames(out) <- rep("", ncol(out))
      rownames(out) <- rep("", nrow(out))


      out <- rbind(out, rep("", 2))

      print(out, quote = FALSE)

    }


  }
  invisible(x)
}

### Leaflet Map ################################################################

### calculate number of failures per switch ------------------------------------

faultsMaster$counter <- 1

tmp <- merge(x = SwitchesMaster, y = faultsMaster[,c("switch_abk","counter")], by = "switch_abk", all.x = TRUE)
rm(faultsMaster)

# calculate number of failures per switch
tmp <- tmp %>%
  group_by(switch_abk,ipid) %>%
  summarise(count_faults = sum(counter)) %>%
  mutate(count_faults = ifelse(is.na(count_faults),0,count_faults)) %>%
  ungroup() %>%
  as.data.frame()

# add calculated feature to master data set
SwitchesMaster <- merge(x = SwitchesMaster, y = tmp[,c("ipid","count_faults")], by = "ipid", all.x = TRUE)
sum(SwitchesMaster$count_faults)
rm(tmp)

### create new data set for the leaflet map ------------------------------------
switches <- SwitchesMaster
rm(SwitchesMaster)

switches$latitude   <- switches$lat
switches$longitude  <- switches$lng
switches$switchID   <- switches$ipid
rownames(switches)  <- switches$ipid
row.names(switches) <- switches$switchID
switches$circlesize <- 1

cleantable <- switches %>%
  select(
    ID            = switchID,
    Line          = line,
    Faults        = count_faults,
    Lat           = latitude,
    Long          = longitude
  )

# change all characters to factors (needed for filters)
for(i in 1:ncol(switches)){
  if(class(switches[,i])[1] == "character"){
    switches[,i] <- as.factor(switches[,i])
  }
}

### Export sessionInfo #########################################################

# sink("www/sessionInfo.txt")
# print(sessionInfo())
# sink()
